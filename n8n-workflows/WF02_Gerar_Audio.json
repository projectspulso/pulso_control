{
  "name": "WF02 - Gerar Áudio TTS (CRON Polling)",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 10
            }
          ]
        }
      },
      "id": "cron-trigger",
      "name": "A cada 10 minutos",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [240, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Buscar roteiros aprovados que ainda não têm áudio gerado\nSELECT \n  r.id as roteiro_id,\n  r.ideia_id,\n  r.canal_id,\n  r.serie_id,\n  r.titulo,\n  r.conteudo_md,\n  r.duracao_estimado_segundos,\n  r.linguagem,\n  r.metadata,\n  i.titulo as ideia_titulo,\n  c.nome as canal_nome,\n  c.slug as canal_slug,\n  c.linguagem as canal_linguagem,\n  p.id as pipeline_id,\n  p.status as pipeline_status\nFROM pulso_content.roteiros r\nINNER JOIN pulso_content.ideias i ON i.id = r.ideia_id\nINNER JOIN pulso_core.canais c ON c.id = r.canal_id\nLEFT JOIN pulso_content.pipeline_producao p ON p.ideia_id = r.ideia_id\nLEFT JOIN pulso_content.audios a ON a.roteiro_id = r.id\nWHERE r.status = 'APROVADO'\n  AND a.id IS NULL  -- Ainda não tem áudio\n  AND r.conteudo_md IS NOT NULL\n  AND LENGTH(r.conteudo_md) > 50\nORDER BY r.created_at ASC\nLIMIT 5;  -- Processar até 5 por vez",
        "options": {}
      },
      "id": "buscar-roteiros",
      "name": "Buscar Roteiros sem Áudio",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [460, 300],
      "credentials": {
        "postgres": {
          "id": "POSTGRES_CREDENTIAL_ID",
          "name": "Postgres supabase"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "check-items",
              "leftValue": "={{ $json.roteiro_id }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-roteiros",
      "name": "Tem Roteiros?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "log-vazio",
              "name": "mensagem",
              "value": "Nenhum roteiro aprovado aguardando geração de áudio",
              "type": "string"
            },
            {
              "id": "timestamp",
              "name": "checked_at",
              "value": "={{ $now.toISO() }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "sem-roteiros",
      "name": "Log - Nenhum Roteiro",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [900, 400]
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "loop-roteiros",
      "name": "Loop - Processar Roteiros",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [900, 200]
    },
    {
      "parameters": {
        "jsCode": "// ==================================================\n// LIMPEZA DE MARKDOWN PARA TTS\n// ==================================================\n\nconst item = $input.item.json;\nconst markdown = item.conteudo_md;\n\nif (!markdown || markdown.trim().length < 50) {\n  throw new Error(`Roteiro ${item.roteiro_id}: conteúdo muito curto ou vazio`);\n}\n\n// ========== LIMPEZA DO MARKDOWN ==========\nlet textoLimpo = markdown\n  // Remover metadados YAML/frontmatter (--- ... ---)\n  .replace(/^---[\\s\\S]*?---/m, '')\n  // Remover títulos markdown (# ## ###)\n  .replace(/^#{1,6}\\s+/gm, '')\n  // Remover bold/italic markdown\n  .replace(/\\*\\*(.+?)\\*\\*/g, '$1')\n  .replace(/\\*(.+?)\\*/g, '$1')\n  .replace(/__(.+?)__/g, '$1')\n  .replace(/_(.+?)_/g, '$1')\n  // Remover links [texto](url) -> manter só texto\n  .replace(/\\[(.+?)\\]\\(.+?\\)/g, '$1')\n  // Remover imagens ![alt](url)\n  .replace(/!\\[.*?\\]\\(.+?\\)/g, '')\n  // Remover listas markdown (-, *, +)\n  .replace(/^[-*+]\\s+/gm, '')\n  // Remover listas numeradas\n  .replace(/^\\d+\\.\\s+/gm, '')\n  // Remover código inline `code`\n  .replace(/`(.+?)`/g, '$1')\n  // Remover blocos de código ```code```\n  .replace(/```[\\s\\S]*?```/g, '')\n  // Remover blockquotes\n  .replace(/^>\\s+/gm, '')\n  // Remover linhas horizontais\n  .replace(/^[-*_]{3,}$/gm, '')\n  // Remover múltiplas quebras de linha\n  .replace(/\\n{3,}/g, '\\n\\n')\n  .trim();\n\n// ========== NORMALIZAÇÃO PARA PRONÚNCIA ==========\ntextoLimpo = textoLimpo\n  // Números e unidades\n  .replace(/\\b([0-9]+)\\s*%/g, '$1 por cento')\n  .replace(/\\b([0-9]+)\\s*km\\b/gi, '$1 quilômetros')\n  .replace(/\\b([0-9]+)\\s*m\\b(?!\\w)/gi, '$1 metros')  // Evitar 'minutos'\n  .replace(/\\b([0-9]+)\\s*kg\\b/gi, '$1 quilogramas')\n  .replace(/\\b([0-9]+)\\s*h\\b(?!\\w)/gi, '$1 horas')\n  .replace(/\\$\\s*([0-9,.]+)/g, '$1 dólares')\n  .replace(/R\\$\\s*([0-9,.]+)/g, '$1 reais')\n  // Abreviações comuns\n  .replace(/\\bDr\\./gi, 'Doutor')\n  .replace(/\\bDra\\./gi, 'Doutora')\n  .replace(/\\bSr\\./gi, 'Senhor')\n  .replace(/\\bSra\\./gi, 'Senhora')\n  .replace(/\\bProf\\./gi, 'Professor')\n  .replace(/\\bEUA\\b/g, 'Estados Unidos')\n  .replace(/\\bONU\\b/g, 'ONU')  // Manter sigla\n  .replace(/\\bNASA\\b/g, 'NASA')\n  // URLs e emails (remover)\n  .replace(/https?:\\/\\/\\S+/g, '')\n  .replace(/\\S+@\\S+\\.\\S+/g, '')\n  // Limpar espaços extras\n  .replace(/\\s+/g, ' ')\n  .trim();\n\n// ========== VALIDAÇÃO DE TAMANHO ==========\nconst totalCaracteres = textoLimpo.length;\nconst maxCaracteresTTS = 4000;  // Limite seguro OpenAI TTS\nconst precisaSplit = totalCaracteres > maxCaracteresTTS;\n\nlet chunks = [];\nif (precisaSplit) {\n  // Dividir em chunks por parágrafos\n  const paragrafos = textoLimpo.split(/\\n\\n+/);\n  let chunkAtual = '';\n  \n  for (const p of paragrafos) {\n    if ((chunkAtual + p).length > maxCaracteresTTS) {\n      if (chunkAtual) chunks.push(chunkAtual.trim());\n      chunkAtual = p;\n    } else {\n      chunkAtual += (chunkAtual ? '\\n\\n' : '') + p;\n    }\n  }\n  if (chunkAtual) chunks.push(chunkAtual.trim());\n} else {\n  chunks = [textoLimpo];\n}\n\n// ========== CUSTO ESTIMADO ==========\n// OpenAI TTS-1-HD: $15.00 / 1M caracteres\nconst custoEstimado = (totalCaracteres / 1000000) * 15;\n\n// ========== OUTPUT ==========\nreturn {\n  json: {\n    // IDs e referências\n    roteiro_id: item.roteiro_id,\n    ideia_id: item.ideia_id,\n    canal_id: item.canal_id,\n    serie_id: item.serie_id,\n    pipeline_id: item.pipeline_id,\n    \n    // Textos\n    titulo: item.titulo,\n    texto_original: markdown,\n    texto_tts: textoLimpo,\n    chunks: chunks,\n    total_chunks: chunks.length,\n    \n    // Métricas\n    total_caracteres: totalCaracteres,\n    custo_estimado_usd: parseFloat(custoEstimado.toFixed(4)),\n    precisa_split: precisaSplit,\n    \n    // Metadata do roteiro\n    linguagem: item.linguagem || item.canal_linguagem || 'pt-BR',\n    duracao_estimada_segundos: item.duracao_estimado_segundos || 60,\n    \n    // Contexto\n    canal_nome: item.canal_nome,\n    canal_slug: item.canal_slug,\n    ideia_titulo: item.ideia_titulo\n  }\n};"
      },
      "id": "limpar-markdown",
      "name": "Limpar Markdown para TTS",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 200]
    },
    {
      "parameters": {
        "jsCode": "// ==================================================\n// SELEÇÃO DE VOZ BASEADA NO IDIOMA\n// ==================================================\n\nconst item = $input.item.json;\nconst linguagem = (item.linguagem || 'pt-BR').toLowerCase();\n\n// ========== MAPEAMENTO DE VOZES POR IDIOMA ==========\n// Vozes OpenAI: alloy, echo, fable, onyx, nova, shimmer\nconst vozMapa = {\n  // Português\n  'pt-br': { voice: 'alloy', speed: 1.0 },\n  'pt-pt': { voice: 'alloy', speed: 0.95 },\n  'pt': { voice: 'alloy', speed: 1.0 },\n  \n  // Inglês\n  'en-us': { voice: 'nova', speed: 1.0 },\n  'en-gb': { voice: 'shimmer', speed: 0.95 },\n  'en': { voice: 'nova', speed: 1.0 },\n  \n  // Espanhol\n  'es-es': { voice: 'fable', speed: 1.0 },\n  'es-mx': { voice: 'onyx', speed: 1.0 },\n  'es': { voice: 'fable', speed: 1.0 },\n  \n  // Francês\n  'fr-fr': { voice: 'echo', speed: 0.95 },\n  'fr': { voice: 'echo', speed: 0.95 },\n  \n  // Alemão\n  'de-de': { voice: 'onyx', speed: 0.95 },\n  'de': { voice: 'onyx', speed: 0.95 },\n  \n  // Italiano\n  'it-it': { voice: 'fable', speed: 1.0 },\n  'it': { voice: 'fable', speed: 1.0 },\n  \n  // Mandarim\n  'zh-cn': { voice: 'nova', speed: 0.9 },\n  'zh-tw': { voice: 'shimmer', speed: 0.9 },\n  'zh': { voice: 'nova', speed: 0.9 },\n  \n  // Japonês\n  'ja-jp': { voice: 'echo', speed: 0.9 },\n  'ja': { voice: 'echo', speed: 0.9 },\n  \n  // Coreano\n  'ko-kr': { voice: 'nova', speed: 0.95 },\n  'ko': { voice: 'nova', speed: 0.95 }\n};\n\n// Buscar configuração ou usar padrão\nconst config = vozMapa[linguagem] || { voice: 'alloy', speed: 1.0 };\n\n// ========== CONFIGURAÇÃO DO TTS ==========\nconst modelo = 'tts-1-hd';  // Melhor qualidade\nconst formato = 'mp3';       // Formato padrão\n\n// ========== PREPARAR CHUNKS PARA PROCESSAMENTO ==========\nconst chunks = item.chunks || [item.texto_tts];\nconst totalChunks = chunks.length;\n\n// Preparar array de jobs (um por chunk)\nconst jobs = chunks.map((texto, index) => ({\n  chunk_index: index + 1,\n  total_chunks: totalChunks,\n  texto: texto,\n  caracteres: texto.length,\n  voice: config.voice,\n  speed: config.speed,\n  modelo: modelo,\n  formato: formato\n}));\n\n// ========== OUTPUT ==========\nreturn {\n  json: {\n    // Dados do roteiro (passar adiante)\n    roteiro_id: item.roteiro_id,\n    ideia_id: item.ideia_id,\n    canal_id: item.canal_id,\n    serie_id: item.serie_id,\n    pipeline_id: item.pipeline_id,\n    titulo: item.titulo,\n    linguagem: item.linguagem,\n    duracao_estimada_segundos: item.duracao_estimada_segundos,\n    total_caracteres: item.total_caracteres,\n    custo_estimado_usd: item.custo_estimado_usd,\n    \n    // Configuração TTS\n    voice: config.voice,\n    speed: config.speed,\n    modelo: modelo,\n    formato: formato,\n    \n    // Chunks para processar\n    total_chunks: totalChunks,\n    precisa_merge: totalChunks > 1,\n    jobs: jobs,\n    \n    // Contexto\n    canal_nome: item.canal_nome,\n    canal_slug: item.canal_slug\n  }\n};"
      },
      "id": "selecionar-voz",
      "name": "Selecionar Voz por Idioma",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 200]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "check-chunks",
              "leftValue": "={{ $json.total_chunks }}",
              "rightValue": "1",
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-split",
      "name": "Precisa Split?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1560, 200]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "texto-unico",
              "name": "texto_tts",
              "value": "={{ $json.jobs[0].texto }}",
              "type": "string"
            },
            {
              "id": "voice-config",
              "name": "voice",
              "value": "={{ $json.voice }}",
              "type": "string"
            },
            {
              "id": "speed-config",
              "name": "speed",
              "value": "={{ $json.speed }}",
              "type": "number"
            },
            {
              "id": "modelo-config",
              "name": "modelo",
              "value": "={{ $json.modelo }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "prep-single",
      "name": "Preparar TTS Único",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [1780, 100]
    },
    {
      "parameters": {
        "fieldToSplitOut": "jobs",
        "options": {}
      },
      "id": "split-chunks",
      "name": "Split em Chunks",
      "type": "n8n-nodes-base.itemLists",
      "typeVersion": 3.4,
      "position": [1780, 300],
      "executeOnce": false
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "chunk-texto",
              "name": "texto_tts",
              "value": "={{ $json.jobs.texto }}",
              "type": "string"
            },
            {
              "id": "chunk-voice",
              "name": "voice",
              "value": "={{ $json.jobs.voice }}",
              "type": "string"
            },
            {
              "id": "chunk-speed",
              "name": "speed",
              "value": "={{ $json.jobs.speed }}",
              "type": "number"
            },
            {
              "id": "chunk-modelo",
              "name": "modelo",
              "value": "={{ $json.jobs.modelo }}",
              "type": "string"
            },
            {
              "id": "chunk-index",
              "name": "chunk_index",
              "value": "={{ $json.jobs.chunk_index }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "id": "prep-chunk",
      "name": "Preparar Chunk",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [2000, 300]
    },
    {
      "parameters": {
        "resource": "audio",
        "operation": "create",
        "model": "={{ $json.modelo }}",
        "input": "={{ $json.texto_tts }}",
        "voice": "={{ $json.voice }}",
        "options": {
          "speed": "={{ $json.speed }}",
          "response_format": "mp3"
        }
      },
      "id": "openai-tts",
      "name": "OpenAI TTS",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.5,
      "position": [2220, 200],
      "credentials": {
        "openAiApi": {
          "id": "OPENAI_CREDENTIAL_ID",
          "name": "OpenAi pulso_control"
        }
      },
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 2000
    },
    {
      "parameters": {
        "jsCode": "// ==================================================\n// PREPARAR UPLOAD PARA SUPABASE STORAGE\n// ==================================================\n\nconst item = $input.item.json;\nconst binary = $input.item.binary;\n\nif (!binary || !binary.data) {\n  throw new Error('Áudio não foi gerado pela OpenAI');\n}\n\n// ========== DEFINIR NOME E PATH ==========\nconst roteiroId = item.roteiro_id || $('Limpar Markdown para TTS').item.json.roteiro_id;\nconst chunkIndex = item.chunk_index;\nconst isChunked = chunkIndex !== undefined;\n\n// Nome do arquivo\nconst filename = isChunked \n  ? `${roteiroId}_chunk${chunkIndex}.mp3`\n  : `${roteiroId}.mp3`;\n\n// Path no storage (organizado por roteiro)\nconst storagePath = `audios/${roteiroId}/${filename}`;\n\n// ========== METADATA DO ARQUIVO ==========\nconst metadata = {\n  roteiro_id: roteiroId,\n  content_type: 'audio/mpeg',\n  cache_control: 'public, max-age=31536000',\n  is_chunk: isChunked,\n  chunk_index: chunkIndex || 1,\n  generated_at: new Date().toISOString()\n};\n\n// ========== OUTPUT ==========\nreturn {\n  json: {\n    roteiro_id: roteiroId,\n    filename: filename,\n    storage_path: storagePath,\n    metadata: metadata,\n    is_chunk: isChunked,\n    chunk_index: chunkIndex || 1\n  },\n  binary: {\n    data: binary.data\n  }\n};"
      },
      "id": "prep-upload",
      "name": "Preparar Upload",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2440, 200]
    },
    {
      "parameters": {
        "operation": "upload",
        "bucketName": "audios",
        "fileName": "={{ $json.storage_path }}",
        "binaryData": true,
        "options": {
          "contentType": "audio/mpeg",
          "cacheControl": "public, max-age=31536000"
        }
      },
      "id": "upload-storage",
      "name": "Upload Supabase Storage",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1.0,
      "position": [2660, 200],
      "credentials": {
        "supabaseApi": {
          "id": "SUPABASE_CREDENTIAL_ID",
          "name": "Supabase Storage – Pulso"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "check-merge",
              "leftValue": "={{ $('Selecionar Voz por Idioma').item.json.precisa_merge }}",
              "rightValue": "true",
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-merge",
      "name": "Precisa Merge?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2880, 200]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "msg-merge",
              "name": "mensagem",
              "value": "Áudio em múltiplos chunks - merge será necessário",
              "type": "string"
            },
            {
              "id": "roteiro-ref",
              "name": "roteiro_id",
              "value": "={{ $('Preparar Upload').item.json.roteiro_id }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "log-merge",
      "name": "Log - Requer Merge",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [3100, 100]
    },
    {
      "parameters": {
        "jsCode": "// ==================================================\n// PREPARAR METADATA FINAL DO ÁUDIO\n// ==================================================\n\nconst roteiroData = $('Limpar Markdown para TTS').item.json;\nconst vozData = $('Selecionar Voz por Idioma').item.json;\nconst uploadData = $input.item.json;\n\n// ========== URL PÚBLICA DO STORAGE ==========\nconst projectId = 'nlcisbfdiokmipyihtuz';\nconst storagePath = uploadData.storage_path || uploadData.path;\nconst publicUrl = `https://${projectId}.supabase.co/storage/v1/object/public/${storagePath}`;\n\n// ========== CALCULAR DURAÇÃO REAL ==========\n// Aproximação: OpenAI TTS ~150 caracteres/segundo (velocidade 1.0)\nconst caracteresTotal = roteiroData.total_caracteres;\nconst velocidade = vozData.speed || 1.0;\nconst duracaoEstimadaSegundos = Math.ceil((caracteresTotal / 150) / velocidade);\n\n// ========== METADATA COMPLETA ==========\nconst metadata = {\n  // Geração\n  provedor: 'openai',\n  modelo: vozData.modelo,\n  voice: vozData.voice,\n  speed: vozData.speed,\n  \n  // Métricas\n  caracteres: caracteresTotal,\n  custo_usd: roteiroData.custo_estimado_usd,\n  duracao_estimada_segundos: duracaoEstimadaSegundos,\n  \n  // Chunks (se aplicável)\n  total_chunks: vozData.total_chunks || 1,\n  precisa_merge: vozData.precisa_merge || false,\n  \n  // Timestamps\n  gerado_em: new Date().toISOString(),\n  workflow_execution_id: $execution.id\n};\n\n// ========== OUTPUT ==========\nreturn {\n  json: {\n    // IDs\n    roteiro_id: roteiroData.roteiro_id,\n    ideia_id: roteiroData.ideia_id,\n    canal_id: roteiroData.canal_id,\n    serie_id: roteiroData.serie_id,\n    \n    // Storage\n    storage_path: storagePath,\n    public_url: publicUrl,\n    \n    // Audio data\n    duracao_segundos: duracaoEstimadaSegundos,\n    linguagem: roteiroData.linguagem,\n    formato: 'audio/mpeg',\n    tipo: 'AUDIO_TTS',\n    status: vozData.precisa_merge ? 'AGUARDANDO_MERGE' : 'OK',\n    \n    // Metadata\n    metadata: metadata,\n    \n    // Contexto\n    titulo: roteiroData.titulo,\n    canal_nome: roteiroData.canal_nome\n  }\n};"
      },
      "id": "prep-metadata",
      "name": "Preparar Metadata Áudio",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3100, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Inserir registro do áudio gerado\nINSERT INTO pulso_content.audios (\n  ideia_id,\n  roteiro_id,\n  canal_id,\n  serie_id,\n  storage_path,\n  public_url,\n  duracao_segundos,\n  linguagem,\n  formato,\n  tipo,\n  status,\n  metadata\n) VALUES (\n  '{{ $json.ideia_id }}',\n  '{{ $json.roteiro_id }}',\n  '{{ $json.canal_id }}',\n  {{ $json.serie_id ? \"'\" + $json.serie_id + \"'\" : 'NULL' }},\n  '{{ $json.storage_path }}',\n  '{{ $json.public_url }}',\n  {{ $json.duracao_segundos }},\n  '{{ $json.linguagem }}',\n  '{{ $json.formato }}',\n  '{{ $json.tipo }}',\n  '{{ $json.status }}',\n  '{{ JSON.stringify($json.metadata) }}'::jsonb\n)\nRETURNING \n  id,\n  roteiro_id,\n  public_url,\n  duracao_segundos,\n  status,\n  created_at;",
        "options": {}
      },
      "id": "insert-audio",
      "name": "Inserir Áudio no DB",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [3320, 300],
      "credentials": {
        "postgres": {
          "id": "POSTGRES_CREDENTIAL_ID",
          "name": "Postgres supabase"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Registrar sucesso no log\nINSERT INTO pulso_content.logs_workflows (\n  workflow_name,\n  execution_id,\n  status,\n  ideia_id,\n  roteiro_id,\n  detalhes\n) VALUES (\n  'WF02_Gerar_Audio_TTS',\n  '{{ $workflow.id }}_{{ $execution.id }}',\n  'sucesso',\n  '{{ $json.ideia_id }}',\n  '{{ $json.roteiro_id }}',\n  jsonb_build_object(\n    'audio_id', '{{ $json.id }}',\n    'public_url', '{{ $json.public_url }}',\n    'duracao_segundos', {{ $json.duracao_segundos }},\n    'status', '{{ $json.status }}',\n    'timestamp', '{{ $json.created_at }}'\n  )\n);",
        "options": {}
      },
      "id": "log-sucesso",
      "name": "Log Sucesso Individual",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [3540, 300],
      "credentials": {
        "postgres": {
          "id": "POSTGRES_CREDENTIAL_ID",
          "name": "Postgres supabase"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "summary-audio",
              "name": "audio_id",
              "value": "={{ $json.id }}",
              "type": "string"
            },
            {
              "id": "summary-roteiro",
              "name": "roteiro_id",
              "value": "={{ $json.roteiro_id }}",
              "type": "string"
            },
            {
              "id": "summary-url",
              "name": "public_url",
              "value": "={{ $json.public_url }}",
              "type": "string"
            },
            {
              "id": "summary-duracao",
              "name": "duracao",
              "value": "={{ $json.duracao_segundos }}s",
              "type": "string"
            },
            {
              "id": "summary-status",
              "name": "status",
              "value": "={{ $json.status }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "prep-resultado",
      "name": "Preparar Resultado",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [3760, 300]
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "destinationFieldName": "audios_gerados",
        "options": {}
      },
      "id": "agregar-resultados",
      "name": "Agregar Resultados",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [3980, 300]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "final-success",
              "name": "success",
              "value": "true",
              "type": "boolean"
            },
            {
              "id": "final-count",
              "name": "total_audios_gerados",
              "value": "={{ $json.audios_gerados.length }}",
              "type": "number"
            },
            {
              "id": "final-timestamp",
              "name": "completed_at",
              "value": "={{ $now.toISO() }}",
              "type": "string"
            },
            {
              "id": "final-execution",
              "name": "execution_id",
              "value": "={{ $execution.id }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "resultado-final",
      "name": "Resultado Final",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [4200, 300]
    }
  ],
  "connections": {
    "A cada 10 minutos": {
      "main": [
        [
          {
            "node": "Buscar Roteiros sem Áudio",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Buscar Roteiros sem Áudio": {
      "main": [
        [
          {
            "node": "Tem Roteiros?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Tem Roteiros?": {
      "main": [
        [
          {
            "node": "Loop - Processar Roteiros",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Log - Nenhum Roteiro",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop - Processar Roteiros": {
      "main": [
        [
          {
            "node": "Limpar Markdown para TTS",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Agregar Resultados",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Limpar Markdown para TTS": {
      "main": [
        [
          {
            "node": "Selecionar Voz por Idioma",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Selecionar Voz por Idioma": {
      "main": [
        [
          {
            "node": "Precisa Split?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Precisa Split?": {
      "main": [
        [
          {
            "node": "Split em Chunks",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Preparar TTS Único",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preparar TTS Único": {
      "main": [
        [
          {
            "node": "OpenAI TTS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split em Chunks": {
      "main": [
        [
          {
            "node": "Preparar Chunk",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preparar Chunk": {
      "main": [
        [
          {
            "node": "OpenAI TTS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI TTS": {
      "main": [
        [
          {
            "node": "Preparar Upload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preparar Upload": {
      "main": [
        [
          {
            "node": "Upload Supabase Storage",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload Supabase Storage": {
      "main": [
        [
          {
            "node": "Precisa Merge?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Precisa Merge?": {
      "main": [
        [
          {
            "node": "Log - Requer Merge",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Preparar Metadata Áudio",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log - Requer Merge": {
      "main": [
        [
          {
            "node": "Preparar Metadata Áudio",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preparar Metadata Áudio": {
      "main": [
        [
          {
            "node": "Inserir Áudio no DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Inserir Áudio no DB": {
      "main": [
        [
          {
            "node": "Log Sucesso Individual",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log Sucesso Individual": {
      "main": [
        [
          {
            "node": "Preparar Resultado",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preparar Resultado": {
      "main": [
        [
          {
            "node": "Loop - Processar Roteiros",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Agregar Resultados": {
      "main": [
        [
          {
            "node": "Resultado Final",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": ""
  },
  "staticData": null,
  "tags": [
    {
      "id": "1",
      "name": "PULSO"
    },
    {
      "id": "2",
      "name": "Automação"
    },
    {
      "id": "3",
      "name": "Audio"
    }
  ],
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "nlcisbfdiokmipyihtuz"
  },
  "id": "WF02",
  "versionId": "2.0.0"
}